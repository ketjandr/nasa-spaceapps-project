<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Photo Sphere Gallery with Search</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; padding:0; overflow:hidden; background:#000; color:white; }
    #searchBar {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 320px;
      padding: 10px 16px;
      font-size: 16px;
      border-radius: 25px;
      border: none;
      outline: none;
      background: rgba(0,0,0,0.5);
      color: white;
      opacity: 0;
      transition: opacity 1s;
      z-index: 10;
    }
    #searchBar.visible { opacity: 1; }
  </style>
</head>
<body>
  <input id="searchBar" type="text" placeholder="Search photos..."/>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/controls/OrbitControls.js';

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 15;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.enableZoom = true;
    controls.rotateSpeed = 0.5;

    const radius = 10;
    const numPhotos = 24;
    const group = new THREE.Group();
    const loader = new THREE.TextureLoader();
    const photoObjects = []; // store planes with their names

    for (let i = 0; i < numPhotos; i++) {
      const phi = Math.acos(-1 + (2 * i) / numPhotos);
      const theta = Math.sqrt(numPhotos * Math.PI) * phi;
      const x = radius * Math.cos(theta) * Math.sin(phi);
      const y = radius * Math.sin(theta) * Math.sin(phi);
      const z = radius * Math.cos(phi);

      const imgURL = `https://picsum.photos/200?random=${i+1}`;
      const texture = loader.load(imgURL);
      const material = new THREE.MeshBasicMaterial({
        map: texture,
        side: THREE.DoubleSide
      });

      const geometry = new THREE.PlaneGeometry(2.5, 2.5);
      const plane = new THREE.Mesh(geometry, material);

      // Add border
      const borderGeom = new THREE.PlaneGeometry(2.6, 2.6);
      const borderMat = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide });
      const border = new THREE.Mesh(borderGeom, borderMat);
      plane.add(border);
      border.position.z = -0.01;

      plane.position.set(x, y, z);
      plane.lookAt(0, 0, 0);
      plane.userData.name = `Photo ${i + 1}`; // give each a name
      group.add(plane);
      photoObjects.push(plane);
    }

    scene.add(group);
    scene.add(new THREE.AmbientLight(0xffffff, 1));

    // === Zoom-in animation on load ===
    let zooming = true;
    const targetZ = radius;
    function animate() {
      requestAnimationFrame(animate);
      if (zooming) {
        camera.position.z -= 0.1;
        if (camera.position.z <= targetZ) {
          camera.position.z = targetZ;
          zooming = false;
          document.getElementById("searchBar").classList.add("visible");
        }
      }
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // === Search + focus functionality ===
    const searchInput = document.getElementById("searchBar");
    let currentTween = null;

    searchInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        const query = e.target.value.toLowerCase().trim();
        if (!query) return;

        // Find a matching photo
        const match = photoObjects.find(p => p.userData.name.toLowerCase().includes(query));
        if (!match) {
          alert("No photo found!");
          return;
        }

        // Smooth camera move toward that photo
        const target = match.position.clone().normalize().multiplyScalar(radius + 3);
        let progress = 0;
        const startPos = camera.position.clone();

        function zoomToPhoto() {
          progress += 0.02;
          if (progress >= 1) {
            camera.position.copy(target);
            camera.lookAt(match.position);
            return;
          }
          camera.position.lerpVectors(startPos, target, progress);
          camera.lookAt(match.position);
          requestAnimationFrame(zoomToPhoto);
        }
        zoomToPhoto();
      }
    });

    // === Handle resize ===
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
