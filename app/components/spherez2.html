<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Globe Gallery</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            background: #000000;
            overflow: hidden;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* Removed #search-container, #search-box, and related classes */
        /* Removed #join-button and related classes */
        /* Removed #back-button and related classes */

        .navigation-hint {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: #999;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.5s ease;
            z-index: 10;
        }

        .navigation-hint.visible {
            opacity: 1;
        }

        .navigation-hint.hidden {
            opacity: 0;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div id="nav-hint" class="navigation-hint">Made with ❤️ by Slack Overflow</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Sample image data with keywords
        const imageData = [
            { image: 'https://picsum.photos/256/256?random=1', title: 'Ear (a)', keywords: ['earbuds', 'audio', 'music', 'ear'], color: '#FFD700' },
            { image: 'https://picsum.photos/256/256?random=2', title: 'Product Showcase', keywords: ['product', 'design', 'showcase', 'items'], color: '#FF6B6B' },
            { image: 'https://picsum.photos/256/256?random=3', title: 'Fashion Photo', keywords: ['fashion', 'style', 'photo', 'model'], color: '#4ECDC4' },
            { image: 'https://picsum.photos/256/256?random=4', title: 'NOTHING Device', keywords: ['nothing', 'tech', 'device', 'phone'], color: '#95E1D3' },
            { image: 'https://picsum.photos/256/256?random=5', title: 'Tech Layout', keywords: ['tech', 'layout', 'modern', 'design'], color: '#F38181' },
            { image: 'https://picsum.photos/256/256?random=6', title: 'User Profile', keywords: ['profile', 'user', 'social', 'person'], color: '#AA96DA' },
            { image: 'https://picsum.photos/256/256?random=7', title: 'Audio Interface', keywords: ['audio', 'interface', 'music', 'sound'], color: '#FCBAD3' },
            { image: 'https://picsum.photos/256/256?random=8', title: 'Product Grid', keywords: ['product', 'grid', 'catalog', 'items'], color: '#A8D8EA' },
            { image: 'https://picsum.photos/256/256?random=9', title: 'Lifestyle Shot', keywords: ['lifestyle', 'casual', 'photo'], color: '#FFE66D' },
            { image: 'https://picsum.photos/256/256?random=10', title: 'Minimal Design', keywords: ['minimal', 'clean', 'simple', 'design'], color: '#C7CEEA' }
        ];

        const RADIUS = 15;
        const COUNT = 50;
        let sprites = [];
        let isDragging = false;
        let prevX = 0;
        let vel = 0;
        let isFocused = false; // Track if we're focused on an image (via double-click)

        // Setup scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 40;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio || 1);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const group = new THREE.Group();
        scene.add(group);

        const ambient = new THREE.AmbientLight(0xffffff, 1.0);
        scene.add(ambient);

        // More scattered, organic distribution with varying angles
        function scatteredSpherePoints(N) {
            const points = [];
            const goldenAngle = Math.PI * (3 - Math.sqrt(5));
            
            for (let i = 0; i < N; i++) {
                // Add some randomness to the distribution
                const offset = (Math.random() - 0.5) * 0.3;
                const y = 1 - (i / (N - 1)) * 2 + offset;
                const radiusAtY = Math.sqrt(1 - y * y);
                
                // Vary the angular distribution
                const theta = i * goldenAngle + (Math.random() - 0.5) * 0.5;
                const x = Math.cos(theta) * radiusAtY;
                const z = Math.sin(theta) * radiusAtY;
                points.push(new THREE.Vector3(x, y, z));
            }
            return points;
        }

        const positions = scatteredSpherePoints(COUNT);

        // Texture loader for images
        const textureLoader = new THREE.TextureLoader();

        // Create sprites with actual images
        for (let i = 0; i < COUNT; i++) {
            const data = imageData[i % imageData.length];
            
            // Load the image as a texture
            textureLoader.load(
                data.image,
                (texture) => {
                    // Image loaded successfully
                    const mat = new THREE.SpriteMaterial({ map: texture });
                    const sprite = new THREE.Sprite(mat);
                    
                    // Vary sprite sizes for more organic feel
                    const sizeVariation = 2.5 + Math.random() * 1;
                    sprite.scale.set(sizeVariation, sizeVariation, 1);
                    
                    const p = positions[i].clone().multiplyScalar(RADIUS);
                    sprite.position.copy(p);
                    
                    sprite.userData = { 
                        index: i, 
                        title: data.title,
                        keywords: data.keywords,
                        color: data.color,
                        originalScale: sizeVariation
                    };
                    
                    group.add(sprite);
                    sprites.push(sprite);
                },
                undefined,
                (error) => {
                    // If image fails to load, create a colored placeholder
                    console.log('Image failed to load, using placeholder:', data.image);
                    const canvas = document.createElement('canvas');
                    canvas.width = 256;
                    canvas.height = 256;
                    const ctx = canvas.getContext('2d');
                    
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, 256, 256);
                    
                    ctx.fillStyle = data.color;
                    ctx.fillRect(0, 0, 256, 60);
                    
                    ctx.fillStyle = '#000000';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(data.title, 128, 140);
                    
                    ctx.strokeStyle = '#e0e0e0';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(0, 0, 256, 256);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    const mat = new THREE.SpriteMaterial({ map: texture });
                    const sprite = new THREE.Sprite(mat);
                    
                    // Vary sprite sizes for more organic feel
                    const sizeVariation = 2.5 + Math.random() * 1;
                    sprite.scale.set(sizeVariation, sizeVariation, 1);
                    
                    const p = positions[i].clone().multiplyScalar(RADIUS);
                    sprite.position.copy(p);
                    
                    sprite.userData = { 
                        index: i, 
                        title: data.title,
                        keywords: data.keywords,
                        color: data.color,
                        originalScale: sizeVariation
                    };
                    
                    group.add(sprite);
                    sprites.push(sprite);
                }
            );
        }

        // Interaction - Dragging
        renderer.domElement.addEventListener('pointerdown', (e) => {
            if (isFocused) return; // Prevent drag while focused
            isDragging = true;
            prevX = e.clientX;
        });

        window.addEventListener('pointerup', () => { 
            isDragging = false; 
        });

        window.addEventListener('pointermove', (e) => {
            if (!isDragging) return;
            const dx = e.clientX - prevX;
            prevX = e.clientX;
            group.rotation.y += dx * 0.005;
            vel = dx * 0.002;
        });

        // Click to view image
        renderer.domElement.addEventListener('click', (ev) => {
            if (isFocused) {
                // If focused, single click resets the view
                resetFocus();
                return;
            }

            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((ev.clientX - rect.left) / rect.width) * 2 - 1,
                -((ev.clientY - rect.top) / rect.height) * 2 + 1
            );
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(group.children, true);
            if (intersects.length > 0) {
                const picked = intersects[0].object;
                if (picked.userData && picked.userData.title) {
                    alert(`Viewing: ${picked.userData.title}`);
                }
            }
        });

        // Double-click to zoom into image
        renderer.domElement.addEventListener('dblclick', (ev) => {
            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((ev.clientX - rect.left) / rect.width) * 2 - 1,
                -((ev.clientY - rect.top) / rect.height) * 2 + 1
            );
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(group.children, true);
            if (intersects.length > 0) {
                const picked = intersects[0].object;
                if (picked.userData && picked.userData.title) {
                    focusOnImage(picked);
                }
            }
        });

        // --- View Control Functions ---
        
        const navHint = document.getElementById('nav-hint');

        function resetFocus() {
            // Unfreeze the rotation
            isFocused = false;

            // Update hint text and show it
            navHint.textContent = 'Drag to rotate • Click image to view';
            navHint.classList.remove('hidden');

            sprites.forEach(s => {
                s.material.opacity = 1;
                s.material.transparent = false;
                const originalScale = s.userData.originalScale || 3;
                s.scale.set(originalScale, originalScale, 1);
            });

            const start = camera.position.clone();
            const end = new THREE.Vector3(0, 0, 22); // Target zoom level

            let t = 0;
            function resetAnim() {
                if (t < 1) {
                    t += 0.02;
                    camera.position.lerpVectors(start, end, t);
                    camera.lookAt(0, 0, 0);
                    requestAnimationFrame(resetAnim);
                }
            }
            resetAnim();
        }

        // Focus on a specific image (used by double-click)
        function focusOnImage(sprite) {
            // Set focused state to freeze rotation
            isFocused = true;

            // Change hint to instruct on how to go back
            navHint.textContent = 'Single-click to go back';

            // Fade out other sprites
            sprites.forEach(s => {
                if (s !== sprite) {
                    s.material.opacity = 0.15;
                    s.material.transparent = true;
                } else {
                    s.material.opacity = 1;
                    s.scale.set(5, 5, 1);
                }
            });

            // Get the world position of the sprite
            const target = new THREE.Vector3();
            sprite.getWorldPosition(target);
            
            // Calculate camera position to focus on the sprite
            const start = camera.position.clone();
            const direction = target.clone().normalize();
            const end = target.clone().add(direction.multiplyScalar(8)); // Position camera closer to the sprite

            let t = 0;
            function zoomAnim() {
                if (t < 1) {
                    t += 0.02;
                    camera.position.lerpVectors(start, end, t);
                    camera.lookAt(target);
                    requestAnimationFrame(zoomAnim);
                }
            }
            zoomAnim();
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Only rotate if not dragging or focused on an image
            if (!isDragging && !isFocused) {
                group.rotation.y += 0.002 + (vel * 0.01);
                vel *= 0.95;
            }
            
            renderer.render(scene, camera);
        }
        animate();

        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Show navigation hint and zoom in slightly on initial load
        setTimeout(() => {
            navHint.classList.add('visible');
            
            // Zoom camera into the middle of the sphere
            const start = camera.position.clone();
            const end = new THREE.Vector3(0, 0, 22); // New default viewing distance

            let t = 0;
            function zoomIntoMiddle() {
                if (t < 1) {
                    t += 0.015; // Slower zoom for smooth effect
                    camera.position.lerpVectors(start, end, t);
                    camera.lookAt(0, 0, 0);
                    requestAnimationFrame(zoomIntoMiddle);
                }
            }
            zoomIntoMiddle();
        }, 3000);
    </script>
</body>
</html>
